<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Manipulating the DOM</title>
        <!-- Load Google Fonts -->
        <link href="https://fonts.googleapis.com/css?family=Fira+Sans:900|Merriweather&display=swap" rel="stylesheet">  <!-- Load Styles -->
        <link href="css/styles.css" rel="stylesheet">
    </head>
    <body>
        <!-- HTML Follows BEM naming conventions 
        IDs are only used for sections to connect menu achors to sections -->
        <header class="page__header">
            <nav class="navbar__menu">
                <ul id="navbar__list">
                </ul>
            </nav>
        </header>
        <main>
            <header class="main__hero">
                <h1>SOLID Principles</h1>
            </header>
            <!-- Each Section has an ID (used for the anchor) and 
            a data attribute that will populate the li node.
            Adding more sections will automatically populate nav.
            The first section is set to active class by default -->
            <section id="section1" data-nav="Section 1" class="your-active-class">
                <div class="landing__container">
                    <h2>Single-Responsibility</h2>
                    <blockquote>
                        A class should have one and only one reason to change, meaning that a class should have only one job.
                    </blockquote>

                    <p>For example, say we have some shapes and we wanted to sum all the areas of the shapes.</p>
                    <p>The argument for the single responsibility principle is relatively simple: <b>it makes your software easier to implement</b> and prevents unexpected side-effects of future changes.</p>
                    <p>The more responsibilities a class has, the more often they need to be changed. If a class implements multiple responsibilities, they are no longer independent of each other.</p>
                    <p>The single responsibility principle provides another substantial benefit. Classes, software components and microservices that have only one responsibility are much easier to explain, understand and implement than the ones that provide a solution for everything. This reduces the number of bugs, improves your development speed, and makes your life as a software developer a lot easier.</p>
                </div>
            </section>
            <section id="section2" data-nav="Section 2">
                <div class="landing__container">
                    <h2>Open-Closed</h2>
                    <blockquote>
                        Objects or entities should be open for extension, but closed for modification.
                    </blockquote>
                    <p>The general idea of this principle is that the developer should be able to add new functionality without changing the existing code. That prevents situations in which a change to one of the classes also requires adaptation of all depending classes.</p>
                    <p>Robert C. Martin promotes the use of interfaces to enable developers to adapt the functionality of their application without changing the existing code.</p>
                </div>
            </section>
            <section id="section3" data-nav="Section 3">
                <div class="landing__container">
                    <h2>Liskov Substitution</h2>
                    <blockquote>
                        Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.
                    </blockquote>
                    <p>All this is stating is that every subclass/derived class should be substitutable for their base/parent class. It extends the Open/Closed Principle by focusing on the behavior of a superclass and its subtypes.</p>
                    <p>The principle defines that objects of a superclass shall be replaceable with objects of its subclasses without breaking the application. That requires the objects of the subclasses to behave in the same way as the objects of the superclass.</p>
                    <p>Unfortunately, there is no easy way to enforce this principle. The compiler only checks the structural rules defined by the Java language, but it canâ€™t enforce a specific behavior.</p>
                </div>
            </section>
            <section id="section4" data-nav="Section 4">
                <div class="landing__container">
                    <h2>Interface Segregation</h2>
                    <blockquote>
                        A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use.
                    </blockquote>
                    <p>The goal of the Interface Segregation Principle is to reduce the side effects and frequency of required changes by splitting the software into multiple, independent parts.</p>
                    <p>By following this principle, bloated interfaces that define methods for multiple responsibilities can be prevented.</p>
                </div>
            </section>
            <section id="section5" data-nav="Section 5">
                <div class="landing__container">
                    <h2>Dependency Inversion</h2>
                    <blockquote>
                        Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions.
                    </blockquote>
                    <p>This principle allows for decoupling.</p>
                    <p>The general idea of this principle is as simple as it is important: High-level modules, which provide complex logic, should be easily reusable and unaffected by changes in low-level modules, which provide utility features. To achieve that, developers need to introduce an abstraction that decouples the high-level and low-level modules from each other.</p>
                </div>
            </section>
            <button id="to_top">Back to top!</button>
        </main>
        <footer class="page__footer">
            <p>&copy adriflorence, 2020</p>
        </footer>
        <script src="js/app.js" type="text/javascript"></script>
    </body>
</html>